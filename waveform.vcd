$date
	Sun Feb 16 18:24:42 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_mips_single_cycle $end
$var wire 1 ! zero $end
$var wire 32 " reg_t3 [31:0] $end
$var wire 32 # reg_t2 [31:0] $end
$var wire 32 $ reg_t1 [31:0] $end
$var wire 32 % reg_t0 [31:0] $end
$var wire 32 & pc [31:0] $end
$var wire 32 ' mem_read_data [31:0] $end
$var wire 32 ( instruction [31:0] $end
$var wire 32 ) alu_result [31:0] $end
$var reg 1 * clk $end
$var reg 1 + reset $end
$scope module uut $end
$var wire 32 , alu_input_2 [31:0] $end
$var wire 1 * clk $end
$var wire 32 - reg_t0 [31:0] $end
$var wire 32 . reg_t1 [31:0] $end
$var wire 32 / reg_t2 [31:0] $end
$var wire 32 0 reg_t3 [31:0] $end
$var wire 1 + reset $end
$var wire 1 ! zero $end
$var wire 32 1 write_data [31:0] $end
$var wire 32 2 sign_extend [31:0] $end
$var wire 1 3 reg_write $end
$var wire 1 4 reg_dst $end
$var wire 32 5 read_data_2 [31:0] $end
$var wire 32 6 read_data_1 [31:0] $end
$var wire 32 7 pc_next [31:0] $end
$var wire 32 8 pc [31:0] $end
$var wire 1 9 mem_write $end
$var wire 1 : mem_to_reg $end
$var wire 32 ; mem_read_data [31:0] $end
$var wire 1 < mem_read $end
$var wire 1 = jump $end
$var wire 32 > instruction [31:0] $end
$var wire 1 ? branch $end
$var wire 1 @ alu_src $end
$var wire 32 A alu_result [31:0] $end
$var wire 2 B alu_op [1:0] $end
$var wire 4 C alu_ctrl [3:0] $end
$scope module IM $end
$var wire 32 D instruction [31:0] $end
$var wire 32 E addr [31:0] $end
$upscope $end
$scope module alu_ctrl_inst $end
$var wire 6 F funct [5:0] $end
$var wire 2 G alu_op [1:0] $end
$var reg 4 H alu_ctrl [3:0] $end
$upscope $end
$scope module alu_inst $end
$var wire 4 I alu_ctrl [3:0] $end
$var wire 32 J b [31:0] $end
$var wire 1 ! zero $end
$var wire 32 K a [31:0] $end
$var reg 32 L result [31:0] $end
$upscope $end
$scope module cu_inst $end
$var wire 6 M opcode [5:0] $end
$var reg 2 N alu_op [1:0] $end
$var reg 1 @ alu_src $end
$var reg 1 ? branch $end
$var reg 1 = jump $end
$var reg 1 < mem_read $end
$var reg 1 : mem_to_reg $end
$var reg 1 9 mem_write $end
$var reg 1 4 reg_dst $end
$var reg 1 3 reg_write $end
$upscope $end
$scope module dm_inst $end
$var wire 32 O addr [31:0] $end
$var wire 1 * clk $end
$var wire 1 < mem_read $end
$var wire 1 9 mem_write $end
$var wire 32 P write_data [31:0] $end
$var wire 32 Q read_data [31:0] $end
$upscope $end
$scope module pc_inst $end
$var wire 1 * clk $end
$var wire 32 R pc_next [31:0] $end
$var wire 1 + reset $end
$var reg 32 S pc [31:0] $end
$upscope $end
$scope module rf_inst $end
$var wire 1 * clk $end
$var wire 32 T read_data1 [31:0] $end
$var wire 32 U read_data2 [31:0] $end
$var wire 5 V read_reg1 [4:0] $end
$var wire 5 W read_reg2 [4:0] $end
$var wire 1 3 reg_write $end
$var wire 1 X reset $end
$var wire 32 Y write_data [31:0] $end
$var wire 5 Z write_reg [4:0] $end
$var integer 32 [ i [31:0] $end
$upscope $end
$scope module se_inst $end
$var wire 16 \ immediate [15:0] $end
$var wire 32 ] extended [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b101 ]
b101 \
bx [
b1001 Z
bx Y
zX
b1001 W
b0 V
bx U
bx T
b0 S
b100 R
b0 Q
bx P
bx O
b0 N
b1000 M
bx L
bx K
bz J
b10 I
b10 H
b0 G
b101 F
b0 E
b100000000010010000000000000101 D
b10 C
b0 B
bx A
1@
0?
b100000000010010000000000000101 >
0=
0<
b0 ;
0:
09
b0 8
b100 7
bx 6
bx 5
04
13
b101 2
bx 1
bx 0
bx /
bx .
bx -
bz ,
1+
0*
bx )
b100000000010010000000000000101 (
b0 '
b0 &
bx %
bx $
bx #
bx "
x!
$end
#5000
1*
#10000
0*
0+
#15000
b1010 Z
b1010 2
b1010 ]
b1010 \
b1010 F
b1010 W
b1000 7
b1000 R
b100000000010100000000000001010 (
b100000000010100000000000001010 >
b100000000010100000000000001010 D
b100 &
b100 8
b100 E
b100 S
1*
#20000
0*
#25000
b1000 Z
b10 B
b10 G
b10 N
0@
14
b100000000100000 2
b100000000100000 ]
b100000000100000 \
b100000 F
b1001 V
b0 M
b1100 7
b1100 R
b1001010100100000000100000 (
b1001010100100000000100000 >
b1001010100100000000100000 D
b1000 &
b1000 8
b1000 E
b1000 S
1*
#30000
0*
#35000
b110 C
b110 H
b110 I
b100000000100010 2
b100000000100010 ]
b100000000100010 \
b100010 F
b10000 7
b10000 R
b1001010100100000000100010 (
b1001010100100000000100010 >
b1001010100100000000100010 D
b1100 &
b1100 8
b1100 E
b1100 S
1*
#40000
0*
#45000
b0 C
b0 H
b0 I
b100000000100100 2
b100000000100100 ]
b100000000100100 \
b100100 F
b10100 7
b10100 R
b1001010100100000000100100 (
b1001010100100000000100100 >
b1001010100100000000100100 D
b10000 &
b10000 8
b10000 E
b10000 S
1*
#50000
0*
#55000
b1 C
b1 H
b1 I
b100000000100101 2
b100000000100101 ]
b100000000100101 \
b100101 F
b11000 7
b11000 R
b1001010100100000000100101 (
b1001010100100000000100101 >
b1001010100100000000100101 D
b10100 &
b10100 8
b10100 E
b10100 S
1*
#60000
0*
#65000
b10 C
b10 H
b10 I
b1010 Z
b0 B
b0 G
b0 N
19
03
1@
04
b0 2
b0 ]
b0 \
b0 F
b0 V
b101011 M
b11100 7
b11100 R
b10101100000010100000000000000000 (
b10101100000010100000000000000000 >
b10101100000010100000000000000000 D
b11000 &
b11000 8
b11000 E
b11000 S
1*
#70000
0*
#75000
bx '
bx ;
bx Q
bx 1
bx Y
b1011 Z
09
1<
13
1:
b1011 W
b100011 M
b100000 7
b100000 R
b10001100000010110000000000000000 (
b10001100000010110000000000000000 >
b10001100000010110000000000000000 D
b11100 &
b11100 8
b11100 E
b11100 S
1*
#80000
0*
#85000
b0 '
b0 ;
b0 Q
b110 C
b110 H
b110 I
b1001 Z
b1 B
b1 G
b1 N
1?
0<
03
0:
0@
b10 2
b10 ]
b10 \
b10 F
b1001 W
b1011 V
b100 M
b10x100 7
b10x100 R
b10001011010010000000000000010 (
b10001011010010000000000000010 >
b10001011010010000000000000010 D
b100000 &
b100000 8
b100000 E
b100000 S
1*
#90000
0*
#95000
b10 C
b10 H
b10 I
bx Z
b0 B
b0 G
b0 N
0?
bx 2
bx ]
bx \
bx F
bx W
bx V
bx M
bx 7
bx R
bx (
bx >
bx D
b10x100 &
b10x100 8
b10x100 E
b10x100 S
1*
#100000
0*
#105000
bx &
bx 8
bx E
bx S
1*
#110000
0*
#115000
1*
#120000
0*
#125000
1*
#130000
0*
#135000
1*
#140000
0*
#145000
1*
#150000
0*
#155000
1*
#160000
0*
#165000
1*
#170000
0*
#175000
1*
#180000
0*
#185000
1*
#190000
0*
#195000
1*
#200000
0*
#205000
1*
#210000
0*
